declare const shader = "\nvarying vec3 v_normal;\nvarying vec4 v_uv[2];\nvarying vec3 v_lightDir;\n// varying vec3 v_eyeVec;\nvarying vec3 v_halfVec;\nvarying vec3 v_teamColor;\nvarying vec4 v_vertexColor;\n\nstruct LayerSettings {\n  bool enabled;\n  float op;\n  float channels;\n  float teamColorMode;\n  // vec3 multAddAlpha;\n  // bool useAlphaFactor;\n  bool invert;\n  // bool multColor;\n  // bool addColor;\n  bool clampResult;\n  // bool useConstantColor;\n  // vec4 constantColor;\n  // float uvSource;\n  float uvCoordinate;\n  // float fresnelMode;\n  // float fresnelTransformMode;\n  // mat4 fresnelTransform;\n  // bool fresnelClamp;\n  // vec3 fresnelExponentBiasScale;\n};\n\nuniform float u_specularity;\nuniform float u_specMult;\nuniform float u_emisMult;\nuniform vec4 u_lightAmbient;\n\nuniform LayerSettings u_diffuseLayerSettings;\nuniform sampler2D u_diffuseMap;\nuniform LayerSettings u_decalLayerSettings;\nuniform sampler2D u_decalMap;\nuniform LayerSettings u_specularLayerSettings;\nuniform sampler2D u_specularMap;\nuniform LayerSettings u_glossLayerSettings;\nuniform sampler2D u_glossMap;\nuniform LayerSettings u_emissiveLayerSettings;\nuniform sampler2D u_emissiveMap;\nuniform LayerSettings u_emissive2LayerSettings;\nuniform sampler2D u_emissive2Map;\nuniform LayerSettings u_evioLayerSettings;\nuniform sampler2D u_evioMap;\nuniform LayerSettings u_evioMaskLayerSettings;\nuniform sampler2D u_evioMaskMap;\nuniform LayerSettings u_alphaLayerSettings;\nuniform sampler2D u_alphaMap;\nuniform LayerSettings u_alphaMaskLayerSettings;\nuniform sampler2D u_alphaMaskMap;\nuniform LayerSettings u_normalLayerSettings;\nuniform sampler2D u_normalMap;\nuniform LayerSettings u_heightLayerSettings;\nuniform sampler2D u_heightMap;\nuniform LayerSettings u_lightMapLayerSettings;\nuniform sampler2D u_lightMapMap;\nuniform LayerSettings u_aoLayerSettings;\nuniform sampler2D u_aoMap;\n\n#define SPECULAR_RGB 0.0\n#define SPECULAR_A_ONLY 1.0\n\n#define FRESNELMODE_NONE 0.0\n#define FRESNELMODE_STANDARD 1.0\n#define FRESNELMODE_INVERTED 2.0\n\n#define FRESNELTRANSFORM_NONE 0.0\n#define FRESNELTRANSFORM_SIMPLE 1.0\n#define FRESNELTRANSFORM_NORMALIZED 2.0\n\n#define UVMAP_EXPLICITUV0 0.0\n#define UVMAP_EXPLICITUV1 1.0\n#define UVMAP_REFLECT_CUBICENVIO 2.0\n#define UVMAP_REFLECT_SPHERICALENVIO 3.0\n#define UVMAP_PLANARLOCALZ 4.0\n#define UVMAP_PLANARWORLDZ 5.0\n#define UVMAP_PARTICLE_FLIPBOOK 6.0\n#define UVMAP_CUBICENVIO 7.0\n#define UVMAP_SPHERICALENVIO 8.0\n#define UVMAP_EXPLICITUV2 9.0\n#define UVMAP_EXPLICITUV3 10.0\n#define UVMAP_PLANARLOCALX 11.0\n#define UVMAP_PLANARLOCALY 12.0\n#define UVMAP_PLANARWORLDX 13.0\n#define UVMAP_PLANARWORLDY 14.0\n#define UVMAP_SCREENSPACE 15.0\n#define UVMAP_TRIPLANAR_LOCAL 16.0\n#define UVMAP_TRIPLANAR_WORLD 17.0\n#define UVMAP_TRIPLANAR_WORLD_LOCAL_Z 18.0\n\n#define CHANNELSELECT_RGB 0.0\n#define CHANNELSELECT_RGBA 1.0\n#define CHANNELSELECT_A 2.0\n#define CHANNELSELECT_R 3.0\n#define CHANNELSELECT_G 4.0\n#define CHANNELSELECT_B 5.0\n\n#define TEAMCOLOR_NONE 0.0\n#define TEAMCOLOR_DIFFUSE 1.0\n#define TEAMCOLOR_EMISSIVE 2.0\n\n#define LAYEROP_MOD 0.0\n#define LAYEROP_MOD2X 1.0\n#define LAYEROP_ADD 2.0\n#define LAYEROP_LERP 3.0\n#define LAYEROP_TEAMCOLOR_EMISSIVE_ADD 4.0\n#define LAYEROP_TEAMCOLOR_DIFFUSE_ADD 5.0\n#define LAYEROP_ADD_NO_ALPHA 6.0\n\n// float calculateFresnelTerm(vec3 normal, vec3 eyeToVertex, float exponent, mat4 fresnelTransform, float fresnelTransformMode, bool fresnelClamp) {\n//   vec3 fresnelDir = eyeToVertex;\n//   float result;\n\n//   if (fresnelTransformMode != FRESNELTRANSFORM_NONE) {\n//     fresnelDir = (fresnelTransform * vec4(fresnelDir, 1.0)).xyz;\n\n//     if (fresnelTransformMode == FRESNELTRANSFORM_NORMALIZED) {\n//       fresnelDir = normalize(fresnelDir);\n//     }\n//   }\n\n//   if (fresnelClamp) {\n//     result = 1.0 - clamp(-dot(normal, fresnelDir), 0.0, 1.0);\n//   } else {\n//     result = 1.0 - abs(dot(normal, fresnelDir));\n//   }\n\n//   result = max(result, 0.0000001);\n\n//   return pow(result, exponent);\n// }\n\nvec3 combineLayerColor(vec4 color, vec3 result, LayerSettings layerSettings) {\n  if (layerSettings.op == LAYEROP_MOD) {\n    result *= color.rgb;\n  } else if (layerSettings.op == LAYEROP_MOD2X) {\n    result *= color.rgb * 2.0;\n  } else if (layerSettings.op == LAYEROP_ADD) {\n    result += color.rgb * color.a;\n  } else if (layerSettings.op == LAYEROP_ADD_NO_ALPHA) {\n    result += color.rgb;\n  } else if (layerSettings.op == LAYEROP_LERP) {\n    result = mix(result, color.rgb, color.a);\n  } else if (layerSettings.op == LAYEROP_TEAMCOLOR_EMISSIVE_ADD) {\n    result += color.a * v_teamColor;\n  } else if (layerSettings.op == LAYEROP_TEAMCOLOR_DIFFUSE_ADD) {\n    result += color.a * v_teamColor;\n  }\n\n  return result;\n}\n\nvec4 chooseChannel(float channel, vec4 texel) {\n  if (channel == CHANNELSELECT_R) {\n    texel = texel.rrrr;\n  } else if (channel == CHANNELSELECT_G) {\n    texel = texel.gggg;\n  } else if (channel == CHANNELSELECT_B) {\n    texel = texel.bbbb;\n  } else if (channel == CHANNELSELECT_A) {\n    texel = texel.aaaa;\n  } else if (channel == CHANNELSELECT_RGB) {\n    texel.a = 1.0;\n  }\n\n  return texel;\n}\n\nvec2 getUV(LayerSettings layerSettings) {\n  if (layerSettings.uvCoordinate == 1.0) {\n    return v_uv[0].zw;\n  } else if (layerSettings.uvCoordinate == 2.0) {\n    return v_uv[1].xy;\n  } else if (layerSettings.uvCoordinate == 3.0) {\n    return v_uv[1].zw;\n  }\n\n  return v_uv[0].xy;\n}\n\nvec4 sampleLayer(sampler2D layer, LayerSettings layerSettings) {\n  // if (layerSettings.useConstantColor) {\n  //   return layerSettings.constantColor;\n  // }\n\n  return texture2D(layer, getUV(layerSettings));\n}\n\nvec4 computeLayerColor(sampler2D layer, LayerSettings layerSettings) {\n  vec4 color = sampleLayer(layer, layerSettings);\n\n  // if (layerSettings.useMask) {\n  //   result *= mask;\n  // }\n\n  vec4 result = chooseChannel(layerSettings.channels, color);\n\n  // if (layerSettings.useAlphaFactor) {\n  //   result.a *= layerSettings.multiplyAddAlpha.z;\n  // }\n\n  if (layerSettings.teamColorMode == TEAMCOLOR_DIFFUSE) {\n    result = vec4(mix(v_teamColor, result.rgb, color.a), 1.0);\n  } else if (layerSettings.teamColorMode == TEAMCOLOR_EMISSIVE) {\n    result = vec4(mix(v_teamColor, result.rgb, color.a), 1.0);\n  }\n\n  if (layerSettings.invert) {\n    result = vec4(1.0) - result;\n  }\n\n  // if (layerSettings.multiplyEnable) {\n  //   result *= layerSettings.multiplyAddAlpha.x;\n  // }\n\n  // if (layerSettings.addEnable) {\n  //   result += layerSettings.multiplyAddAlpha.y;\n  // }\n\n  if (layerSettings.clampResult) {\n    result = clamp(result, 0.0, 1.0);\n  }\n\n  // if (layerSettings.fresnelMode != FRESNELMODE_NONE) {\n  //   float fresnelTerm = calculateFresnelTerm(v_normal, v_eyeVec, layerSettings.fresnelExponentBiasScale.x, layerSettings.fresnelTransform, layerSettings.fresnelTransformMode, layerSettings.fresnelClamp);\n    \n  //   if (layerSettings.fresnelMode == FRESNELMODE_INVERTED) {\n  //     fresnelTerm = 1.0 - fresnelTerm;\n  //   }\n    \n  //   fresnelTerm = clamp(fresnelTerm * layerSettings.fresnelExponentBiasScale.z + layerSettings.fresnelExponentBiasScale.y, 0.0, 1.0);\n    \n  //   result *= fresnelTerm;\n  // }\n\n  return result;\n}\n\nvec3 decodeNormal(sampler2D map) {\n  vec4 texel = texture2D(map, v_uv[0].xy);\n  vec3 normal;\n\n  normal.xy = 2.0 * texel.wy - 1.0;\n  normal.z = sqrt(max(0.0, 1.0 - dot(normal.xy, normal.xy)));\n\n  return normal;\n}\n\nvec4 computeSpecular(sampler2D specularMap, LayerSettings layerSettings, float specularity, float specMult, vec3 normal) {\n  vec4 color;\n\n  if (layerSettings.enabled) {\n    color = computeLayerColor(specularMap, layerSettings);\n  } else {\n    color = vec4(0);\n  }\n\n  float factor = pow(max(-dot(v_halfVec, normal), 0.0), specularity) * specMult;\n\n  return color * factor;\n}\n";
export default shader;
