declare const shader = "\nuniform mat4 u_VP;\nuniform sampler2D u_heightMap;\nuniform vec2 u_size;\nuniform vec2 u_offset;\nuniform bool u_extended[14];\nuniform float u_baseTileset;\n\nattribute vec2 a_position;\nattribute float a_InstanceID;\nattribute vec4 a_textures;\nattribute vec4 a_variations;\n\nvarying vec4 v_tilesets;\nvarying vec2 v_uv[4];\nvarying vec3 v_normal;\n\nvec2 getCell(float variation) {\n  if (variation < 16.0) {\n    return vec2(mod(variation, 4.0), floor(variation / 4.0));\n  } else {\n    variation -= 16.0;\n\n    return vec2(4.0 + mod(variation, 4.0), floor(variation / 4.0));\n  }\n}\n\nvec2 getUV(vec2 position, bool extended, float variation) {\n  vec2 cell = getCell(variation);\n  vec2 cellSize = vec2(extended ? 0.125 : 0.25, 0.25);\n  vec2 uv = vec2(position.x, 1.0 - position.y);\n  vec2 pixelSize = vec2(1.0 / 512.0, 1.0 / 256.0); /// Note: hardcoded to 512x256 for now.\n\n  return clamp((cell + uv) * cellSize, cell * cellSize + pixelSize, (cell + 1.0) * cellSize - pixelSize); \n}\n\nvoid main() {\n  vec4 textures = a_textures - u_baseTileset;\n  \n  if (textures[0] > 0.0 || textures[1] > 0.0 || textures[2] > 0.0 || textures[3] > 0.0) {\n    v_tilesets = textures;\n\n    v_uv[0] = getUV(a_position, u_extended[int(textures[0]) - 1], a_variations[0]);\n    v_uv[1] = getUV(a_position, u_extended[int(textures[1]) - 1], a_variations[1]);\n    v_uv[2] = getUV(a_position, u_extended[int(textures[2]) - 1], a_variations[2]);\n    v_uv[3] = getUV(a_position, u_extended[int(textures[3]) - 1], a_variations[3]);\n\n    vec2 corner = vec2(mod(a_InstanceID, u_size.x), floor(a_InstanceID / u_size.x));\n    vec2 base = corner + a_position;\n    float height = texture2D(u_heightMap, base / u_size).a;\n\n    float hL = texture2D(u_heightMap, vec2(base - vec2(1.0, 0.0)) / (u_size)).a;\n    float hR = texture2D(u_heightMap, vec2(base + vec2(1.0, 0.0)) / (u_size)).a;\n    float hD = texture2D(u_heightMap, vec2(base - vec2(0.0, 1.0)) / (u_size)).a;\n    float hU = texture2D(u_heightMap, vec2(base + vec2(0.0, 1.0)) / (u_size)).a;\n\n    v_normal = normalize(vec3(hL - hR, hD - hU, 2.0));\n\n    gl_Position = u_VP * vec4(base * 128.0 + u_offset, height * 128.0, 1.0);\n  } else {\n    v_tilesets = vec4(0.0);\n\n    v_uv[0] = vec2(0.0);\n    v_uv[1] = vec2(0.0);\n    v_uv[2] = vec2(0.0);\n    v_uv[3] = vec2(0.0);\n\n    v_normal = vec3(0.0);\n\n    gl_Position = vec4(0.0);\n  }\n}\n";
export default shader;
